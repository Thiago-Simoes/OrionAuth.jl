var documenterSearchIndex = {"docs":
[{"location":"manual/start/#Quick-Start","page":"Quick Start","title":"Quick Start","text":"","category":"section"},{"location":"manual/start/#Prerequisites","page":"Quick Start","title":"Prerequisites","text":"","category":"section"},{"location":"manual/start/","page":"Quick Start","title":"Quick Start","text":"Ensure you have Julia installed.\nClone the repository and install dependencies:\nimport Pkg\nPkg.activate(\".\")\nPkg.add(\"https://github.com/Thiago-Simoes/OrionAuth.jl\")\n\nusing OrionAuth\n","category":"page"},{"location":"manual/start/#Configuration","page":"Quick Start","title":"Configuration","text":"","category":"section"},{"location":"manual/start/","page":"Quick Start","title":"Quick Start","text":"Create a .env file in the repository root with:","category":"page"},{"location":"manual/start/","page":"Quick Start","title":"Quick Start","text":"DB_HOST=localhost\nDB_USER=root\nDB_PASSWORD=pass\nDB_NAME=dbname\nDB_PORT=3306\n\nOrionORM_LOG_LEVEL=error\nOrionAuth_SECRET=your_secret_key_here\nOrionAuth_ALGORITHM=HS512\nOrionAuth_EXPIRATION=3600\nOrionAuth_ISSUER=OrionAuth\nOrionAuth_DBPREFIX=OrionAuth_\nOrionAuth_MIN_PASSWORD_ITTERATIONS=25000","category":"page"},{"location":"manual/start/#Initializing-the-Package","page":"Quick Start","title":"Initializing the Package","text":"","category":"section"},{"location":"manual/start/","page":"Quick Start","title":"Quick Start","text":"In your Julia script or REPL, load and initialize OrionAuth:","category":"page"},{"location":"manual/start/","page":"Quick Start","title":"Quick Start","text":"using OrionAuth\nOrionAuth.init!()  # Loads all modules, including auth and JWT.","category":"page"},{"location":"manual/start/#User-Operations","page":"Quick Start","title":"User Operations","text":"","category":"section"},{"location":"manual/start/#Signing-Up","page":"Quick Start","title":"Signing Up","text":"","category":"section"},{"location":"manual/start/","page":"Quick Start","title":"Quick Start","text":"Create a new user with:","category":"page"},{"location":"manual/start/","page":"Quick Start","title":"Quick Start","text":"user = OrionAuth.signup(\"user@example.com\", \"John Doe\", \"securePassword123\")\nprintln(\"User created with UUID: \", user.uuid)","category":"page"},{"location":"manual/start/#Signing-In","page":"Quick Start","title":"Signing In","text":"","category":"section"},{"location":"manual/start/","page":"Quick Start","title":"Quick Start","text":"Authenticate a user with:","category":"page"},{"location":"manual/start/","page":"Quick Start","title":"Quick Start","text":"user = OrionAuth.signin(\"user@example.com\", \"securePassword123\")\nprintln(\"User signed in successfully!\")","category":"page"},{"location":"manual/relationships/#Defining-Relationships","page":"Defining Relationships","title":"Defining Relationships","text":"","category":"section"},{"location":"manual/relationships/","page":"Defining Relationships","title":"Defining Relationships","text":"OrionAuth leverages OrionORM to create relationships between models. This manual explains how to create related models and query them.","category":"page"},{"location":"manual/relationships/#Creating-Related-Models","page":"Defining Relationships","title":"Creating Related Models","text":"","category":"section"},{"location":"manual/relationships/","page":"Defining Relationships","title":"Defining Relationships","text":"You can define relationships by specifying association attributes when creating a model. For example, defining a Profile linked to a user:","category":"page"},{"location":"manual/relationships/","page":"Defining Relationships","title":"Defining Relationships","text":"Model(\n    :Profile,\n    [\n        (\"id\", INTEGER(), [PrimaryKey(), AutoIncrement()]),\n        (\"userId\", INTEGER(), []),\n        (\"bio\", TEXT(), []),\n        (\"location\", TEXT(), []),\n        (\"website\", TEXT(), []),\n        (\"created_at\", TIMESTAMP(), [Default(\"CURRENT_TIMESTAMP()\")]),\n        (\"updated_at\", TIMESTAMP(), [Default(\"CURRENT_TIMESTAMP()\")])\n    ],\n    [\n        (\"userId\", OrionAuth_User, \"id\", :belongsTo)\n    ]\n)","category":"page"},{"location":"manual/relationships/#Creating-and-Querying-Relationships","page":"Defining Relationships","title":"Creating and Querying Relationships","text":"","category":"section"},{"location":"manual/relationships/","page":"Defining Relationships","title":"Defining Relationships","text":"After creating the models, you can create a profile for a user:","category":"page"},{"location":"manual/relationships/","page":"Defining Relationships","title":"Defining Relationships","text":"profile = create(Profile, Dict(\n    \"userId\" => user.id,\n    \"bio\" => \"Software Engineer\",\n    \"location\" => \"Brazil\",\n    \"website\" => \"https://example.com\"\n))","category":"page"},{"location":"manual/relationships/#Query-Examples","page":"Defining Relationships","title":"Query Examples","text":"","category":"section"},{"location":"manual/relationships/","page":"Defining Relationships","title":"Defining Relationships","text":"Fetch the profile by user id:\nprofile_user = findFirst(Profile; query=Dict(\"where\" => Dict(\"userId\" => user.id)))\nInclude the related model when querying a user:\nprofile_user_with_relation = findFirst(OrionAuth_User; query=Dict(\"where\" => Dict(\"id\" => profile.userId), \"include\" => [Profile]))","category":"page"},{"location":"manual/relationships/","page":"Defining Relationships","title":"Defining Relationships","text":"This will return a user record with an embedded list of related profiles.","category":"page"},{"location":"security/security_policy/#OrionAuth-Security-Policy","page":"OrionAuth Security Policy","title":"OrionAuth Security Policy","text":"","category":"section"},{"location":"security/security_policy/#Overview","page":"OrionAuth Security Policy","title":"Overview","text":"","category":"section"},{"location":"security/security_policy/","page":"OrionAuth Security Policy","title":"OrionAuth Security Policy","text":"OrionAuth.jl is designed to provide simple and robust authentication and authorization mechanisms. This document outlines the security objectives, methodologies, enforced practices, limitations, and future plans.","category":"page"},{"location":"security/security_policy/","page":"OrionAuth Security Policy","title":"OrionAuth Security Policy","text":"","category":"page"},{"location":"security/security_policy/#Objectives","page":"OrionAuth Security Policy","title":"Objectives","text":"","category":"section"},{"location":"security/security_policy/","page":"OrionAuth Security Policy","title":"OrionAuth Security Policy","text":"Provide strong and simple authentication.\nSupport robust authorization via RBAC with editable roles and permissions.\nEnsure auditability through logging and session management.\nPrevent common web application vulnerabilities related to authentication and authorization.","category":"page"},{"location":"security/security_policy/","page":"OrionAuth Security Policy","title":"OrionAuth Security Policy","text":"","category":"page"},{"location":"security/security_policy/#Authentication","page":"OrionAuth Security Policy","title":"Authentication","text":"","category":"section"},{"location":"security/security_policy/#Supported-Methods","page":"OrionAuth Security Policy","title":"Supported Methods","text":"","category":"section"},{"location":"security/security_policy/","page":"OrionAuth Security Policy","title":"OrionAuth Security Policy","text":"Password-based authentication only.","category":"page"},{"location":"security/security_policy/#Password-Storage","page":"OrionAuth Security Policy","title":"Password Storage","text":"","category":"section"},{"location":"security/security_policy/","page":"OrionAuth Security Policy","title":"OrionAuth Security Policy","text":"Argon2id (libsodium) with moderate memory & CPU cost parameters by default.\nEnvironment-selectable choice between built-in Argon2id (default) and legacy SHA-512 hashing via OrionAuth_PASSWORD_ALGORITHM.\nLegacy SHA-512 hashing remains available for compatibility (opt-in).","category":"page"},{"location":"security/security_policy/#Password-Requirements-and-Checks","page":"OrionAuth Security Policy","title":"Password Requirements and Checks","text":"","category":"section"},{"location":"security/security_policy/","page":"OrionAuth Security Policy","title":"OrionAuth Security Policy","text":"No current enforcement of password strength beyond storage.\nNo verification against leaked password databases (planned).\nFuture plan: check passwords against common password lists and compromised datasets (e.g. SecLists).","category":"page"},{"location":"security/security_policy/#Protection-Against-Brute-Force","page":"OrionAuth Security Policy","title":"Protection Against Brute Force","text":"","category":"section"},{"location":"security/security_policy/","page":"OrionAuth Security Policy","title":"OrionAuth Security Policy","text":"No rate limiting or brute force protection implemented.\nPlanned for future releases.","category":"page"},{"location":"security/security_policy/#JWT-Handling","page":"OrionAuth Security Policy","title":"JWT Handling","text":"","category":"section"},{"location":"security/security_policy/","page":"OrionAuth Security Policy","title":"OrionAuth Security Policy","text":"JWTs are always required to be signed.\nUnsigned JWTs are rejected by default.\nNo need for the integrator to manually validate JWT signature.","category":"page"},{"location":"security/security_policy/","page":"OrionAuth Security Policy","title":"OrionAuth Security Policy","text":"","category":"page"},{"location":"security/security_policy/#Authorization","page":"OrionAuth Security Policy","title":"Authorization","text":"","category":"section"},{"location":"security/security_policy/#General-Approach","page":"OrionAuth Security Policy","title":"General Approach","text":"","category":"section"},{"location":"security/security_policy/","page":"OrionAuth Security Policy","title":"OrionAuth Security Policy","text":"Authorization is manual and route protection is integrator's responsibility.\nNo automatic access control check (Force Every Access Check - RFC2904 is not applied).\nAbuse cases like authorization bypass and missing checks are mitigated by enforcing best practices on the integrator side.","category":"page"},{"location":"security/security_policy/#Access-Control-Model","page":"OrionAuth Security Policy","title":"Access Control Model","text":"","category":"section"},{"location":"security/security_policy/","page":"OrionAuth Security Policy","title":"OrionAuth Security Policy","text":"RBAC is implemented.\nRoles can be assigned multiple permissions.\nPolicies (e.g., admin_edit_userData) can be hard-coded.\nHard-coding of roles is discouraged.\nDeny by default: roles start with no permissions.\nLeast privilege is enforced by design.","category":"page"},{"location":"security/security_policy/#Abuse-Cases-Covered","page":"OrionAuth Security Policy","title":"Abuse Cases Covered","text":"","category":"section"},{"location":"security/security_policy/","page":"OrionAuth Security Policy","title":"OrionAuth Security Policy","text":"Broken Access Control (OWASP Top 10 2021 A01)\nCWE-862 (Missing Authorization)\nCWE-863 (Incorrect Authorization)\nJWT signature validation (disallows unsigned tokens)","category":"page"},{"location":"security/security_policy/#Abuse-Cases-Not-Covered","page":"OrionAuth Security Policy","title":"Abuse Cases Not Covered","text":"","category":"section"},{"location":"security/security_policy/","page":"OrionAuth Security Policy","title":"OrionAuth Security Policy","text":"Automatic route protection (manual responsibility of integrator)","category":"page"},{"location":"security/security_policy/","page":"OrionAuth Security Policy","title":"OrionAuth Security Policy","text":"","category":"page"},{"location":"security/security_policy/#Secrets-Management","page":"OrionAuth Security Policy","title":"Secrets Management","text":"","category":"section"},{"location":"security/security_policy/","page":"OrionAuth Security Policy","title":"OrionAuth Security Policy","text":"Application secrets (keys, secrets, configuration) are handled via environment variables (ENV).\nSecrets should be injected via secure channels (CI/CD, deployment tools).","category":"page"},{"location":"security/security_policy/","page":"OrionAuth Security Policy","title":"OrionAuth Security Policy","text":"","category":"page"},{"location":"security/security_policy/#Logging-and-Audit-Trail","page":"OrionAuth Security Policy","title":"Logging and Audit Trail","text":"","category":"section"},{"location":"security/security_policy/","page":"OrionAuth Security Policy","title":"OrionAuth Security Policy","text":"Built-in logging of critical events:\nSign in\nSign out\nSign up\nRole assignment\nRole removal\nAccess usage\nIntegrator responsible for securing logs and ensuring integrity.","category":"page"},{"location":"security/security_policy/","page":"OrionAuth Security Policy","title":"OrionAuth Security Policy","text":"","category":"page"},{"location":"security/security_policy/#References-and-Standards","page":"OrionAuth Security Policy","title":"References and Standards","text":"","category":"section"},{"location":"security/security_policy/","page":"OrionAuth Security Policy","title":"OrionAuth Security Policy","text":"OWASP Cheat Sheet Series:\nAuthorization Cheat Sheet\nLogging Cheat Sheet\nInsecure Direct Object Reference Prevention Cheat Sheet\nOWASP ASVS V4 (Access Control)\nOWASP Testing Guide (Authorization Testing)\nOWASP Top 10 2021 - A01 Broken Access Control\nCWE Top 25:\nCWE-862 Missing Authorization\nCWE-863 Incorrect Authorization\nOAuth 2.0 Protocol\nOAuth 2.1 Draft\nPolicy Enforcement in RFC 2904 (referenced, not applied)\nNIST 800-63b (Authentication Assurance Level 1)","category":"page"},{"location":"security/security_policy/","page":"OrionAuth Security Policy","title":"OrionAuth Security Policy","text":"","category":"page"},{"location":"security/security_policy/#Limitations","page":"OrionAuth Security Policy","title":"Limitations","text":"","category":"section"},{"location":"security/security_policy/","page":"OrionAuth Security Policy","title":"OrionAuth Security Policy","text":"Route protection is the integrator's responsibility.\nNo rate limiting or brute force protections (planned).\nPassword leak detection not implemented (planned).\nNo MFA support yet (planned).","category":"page"},{"location":"security/security_policy/","page":"OrionAuth Security Policy","title":"OrionAuth Security Policy","text":"","category":"page"},{"location":"security/security_policy/#Roadmap-(Future-Plans)","page":"OrionAuth Security Policy","title":"Roadmap (Future Plans)","text":"","category":"section"},{"location":"security/security_policy/","page":"OrionAuth Security Policy","title":"OrionAuth Security Policy","text":"Expand optional password algorithms (e.g., bcrypt) and tooling around Argon2id parameter tuning.\nImplement password leak and common password verification.\nAdd Multi-Factor Authentication support.\nAdd rate limiting and brute force protection mechanisms.\nPotential future automatic route protection and authorization integration.","category":"page"},{"location":"security/security_policy/","page":"OrionAuth Security Policy","title":"OrionAuth Security Policy","text":"","category":"page"},{"location":"security/security_policy/#Change-Log","page":"OrionAuth Security Policy","title":"Change Log","text":"","category":"section"},{"location":"security/security_policy/","page":"OrionAuth Security Policy","title":"OrionAuth Security Policy","text":"Initial version.","category":"page"},{"location":"Reference/API/#API","page":"API","title":"API","text":"","category":"section"},{"location":"Reference/API/#OrionAuth.GenericRequestContext","page":"API","title":"OrionAuth.GenericRequestContext","text":"GenericRequestContext <: RequestContext\n\nGeneric implementation of RequestContext for testing and direct use.\n\nFields\n\nheaders::Dict{String,String}: HTTP request headers\n\nExamples\n\nctx = GenericRequestContext(Dict(\"Authorization\" => \"Bearer token123\"))\ntoken = extract_bearer_token(ctx)\n\n\n\n\n\n","category":"type"},{"location":"Reference/API/#OrionAuth.HTTPRequestContext","page":"API","title":"OrionAuth.HTTPRequestContext","text":"HTTPRequestContext <: RequestContext\n\nAdapter for HTTP.jl requests.\n\nExamples\n\nusing HTTP\n\n# In an HTTP.jl handler:\nHTTP.serve() do req\n    ctx = HTTPRequestContext(req)\n    try\n        payload = Auth(ctx)\n        return HTTP.Response(200, \"Success\")\n    catch ex\n        if ex isa ResponseException\n            return to_http_response(ex)\n        end\n        rethrow()\n    end\nend\n\n\n\n\n\n","category":"type"},{"location":"Reference/API/#OrionAuth.OxygenRequestContext","page":"API","title":"OrionAuth.OxygenRequestContext","text":"OxygenRequestContext <: RequestContext\n\nAdapter for Oxygen framework requests.\n\nExamples\n\nusing Oxygen\n\n# In an Oxygen route handler:\n@get \"/protected\" function(req)\n    ctx = OxygenRequestContext(req)\n    payload = Auth(ctx)\n    # ... handle request\nend\n\n\n\n\n\n","category":"type"},{"location":"Reference/API/#OrionAuth.RequestContext","page":"API","title":"OrionAuth.RequestContext","text":"RequestContext\n\nAbstract type representing an HTTP request context across different frameworks. Implementations should provide access to request headers.\n\n\n\n\n\n","category":"type"},{"location":"Reference/API/#OrionAuth.ResponseException","page":"API","title":"OrionAuth.ResponseException","text":"ResponseException\n\nException type for HTTP responses with status code, headers, and body. Can be thrown to return an HTTP error response in a framework-agnostic way.\n\nFields\n\nstatus::Int: HTTP status code (e.g., 401, 403, 404)\nheaders::Vector{Pair{String,String}}: HTTP response headers\nbody::String: Response body content\n\nExamples\n\n# Unauthorized response\nthrow(ResponseException(401, [], \"Unauthorized\"))\n\n# Forbidden with custom header\nthrow(ResponseException(403, [\"Content-Type\" => \"application/json\"], \"Forbidden\"))\n\n\n\n\n\n","category":"type"},{"location":"Reference/API/#OrionAuth.configure_framework!-Tuple{Symbol}","page":"API","title":"OrionAuth.configure_framework!","text":"configure_framework!(framework::Symbol)\n\nConfigure OrionAuth to use a specific framework adapter.\n\nArguments\n\nframework::Symbol: Framework to use (:genie, :oxygen, :http, or :auto)\n\nExamples\n\n# Set framework explicitly\nconfigure_framework!(:genie)\n\n# Enable auto-detection (default)\nconfigure_framework!(:auto)\n\n\n\n\n\n","category":"method"},{"location":"Reference/API/#OrionAuth.create_request_context","page":"API","title":"OrionAuth.create_request_context","text":"create_request_context(request=nothing) -> RequestContext\n\nAutomatically create the appropriate RequestContext based on configuration or auto-detection.\n\nArguments\n\nrequest: Optional request object (auto-detected if not provided)\n\nReturns\n\nRequestContext: Appropriate context for the configured/detected framework\n\nExamples\n\n# Auto-detect from environment\nctx = create_request_context()\n\n# Explicit request object\nctx = create_request_context(req)\n\n\n\n\n\n","category":"function"},{"location":"Reference/API/#OrionAuth.extract_bearer_token-Tuple{RequestContext}","page":"API","title":"OrionAuth.extract_bearer_token","text":"extract_bearer_token(ctx::RequestContext) -> String\n\nExtract JWT token from the Authorization Bearer header.\n\nArguments\n\nctx::RequestContext: The request context with headers\n\nReturns\n\nString: The JWT token\n\nThrows\n\nResponseException(401, ...): If Authorization header is missing\nResponseException(400, ...): If Authorization header format is invalid\n\nExamples\n\ntoken = extract_bearer_token(ctx)\n# Returns: \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\"\n\n\n\n\n\n","category":"method"},{"location":"Reference/API/#OrionAuth.get_configured_framework-Tuple{}","page":"API","title":"OrionAuth.get_configured_framework","text":"get_configured_framework() -> Symbol\n\nGet the currently configured framework.\n\nReturns\n\nSymbol representing the framework (:genie, :oxygen, :http, or :auto)\n\n\n\n\n\n","category":"method"},{"location":"Reference/API/#OrionAuth.get_headers","page":"API","title":"OrionAuth.get_headers","text":"get_headers(ctx::RequestContext) -> Dict{String,String}\n\nExtract headers from the request context.\n\nArguments\n\nctx::RequestContext: The request context\n\nReturns\n\nDict{String,String}: Dictionary of HTTP headers\n\nExamples\n\nheaders = get_headers(ctx)\nauth_header = get(headers, \"authorization\", nothing)\n\n\n\n\n\n","category":"function"},{"location":"Reference/API/#OrionAuth.get_headers-Tuple{HTTPRequestContext}","page":"API","title":"OrionAuth.get_headers","text":"get_headers(ctx::HTTPRequestContext) -> Dict{String,String}\n\nExtract headers from HTTP.Request.\n\nArguments\n\nctx::HTTPRequestContext: HTTP request context\n\nReturns\n\nDict{String,String}: Dictionary of HTTP headers\n\n\n\n\n\n","category":"method"},{"location":"Reference/API/#OrionAuth.get_headers-Tuple{OxygenRequestContext}","page":"API","title":"OrionAuth.get_headers","text":"get_headers(ctx::OxygenRequestContext) -> Dict{String,String}\n\nExtract headers from Oxygen request context.\n\nArguments\n\nctx::OxygenRequestContext: Oxygen request context\n\nReturns\n\nDict{String,String}: Dictionary of HTTP headers\n\n\n\n\n\n","category":"method"},{"location":"Reference/API/#OrionAuth.handle_auth_exception-Tuple{ResponseException}","page":"API","title":"OrionAuth.handle_auth_exception","text":"handle_auth_exception(ex::ResponseException) -> Any\n\nConvert ResponseException to the appropriate framework-specific response.\n\nArguments\n\nex::ResponseException: The exception to convert\n\nReturns\n\nFramework-specific error response\n\nExamples\n\ntry\n    Auth()\ncatch ex\n    if ex isa ResponseException\n        return handle_auth_exception(ex)\n    end\n    rethrow()\nend\n\n\n\n\n\n","category":"method"},{"location":"Reference/API/#OrionAuth.to_http_response-Tuple{ResponseException}","page":"API","title":"OrionAuth.to_http_response","text":"to_http_response(ex::ResponseException) -> HTTP.Response\n\nConvert ResponseException to HTTP.Response.\n\nArguments\n\nex::ResponseException: The response exception to convert\n\nReturns\n\nHTTP.Response: HTTP response with status, headers, and body\n\n\n\n\n\n","category":"method"},{"location":"Reference/API/#OrionAuth.to_oxygen_response-Tuple{ResponseException}","page":"API","title":"OrionAuth.to_oxygen_response","text":"to_oxygen_response(ex::ResponseException) -> HTTP.Response\n\nConvert ResponseException to HTTP.Response for Oxygen.\n\nArguments\n\nex::ResponseException: The response exception to convert\n\nReturns\n\nHTTP.Response: HTTP response with status, headers, and body\n\n\n\n\n\n","category":"method"},{"location":"manual/security/#OrionAuth-Security-Considerations-and-Best-Practices","page":"OrionAuth Security Considerations and Best Practices","title":"OrionAuth Security Considerations and Best Practices","text":"","category":"section"},{"location":"manual/security/","page":"OrionAuth Security Considerations and Best Practices","title":"OrionAuth Security Considerations and Best Practices","text":"This document describes OrionAuth’s built-in security features, recommended configurations, and references to industry standards. Follow these guidelines to securely integrate OrionAuth into your applications, ranging from MVPs to more sensitive deployments.","category":"page"},{"location":"manual/security/","page":"OrionAuth Security Considerations and Best Practices","title":"OrionAuth Security Considerations and Best Practices","text":"Última atualização: 16 de Setembro de 2025","category":"page"},{"location":"manual/security/#1.-Standards-and-References","page":"OrionAuth Security Considerations and Best Practices","title":"1. Standards and References","text":"","category":"section"},{"location":"manual/security/","page":"OrionAuth Security Considerations and Best Practices","title":"OrionAuth Security Considerations and Best Practices","text":"OrionAuth aims to align with and support applications adhering to security best practices and standards. We recommend familiarizing yourself with the following:","category":"page"},{"location":"manual/security/","page":"OrionAuth Security Considerations and Best Practices","title":"OrionAuth Security Considerations and Best Practices","text":"JWT (RFC 7519): JSON Web Token specification for stateless, secure session handling, which is a core component of OrionAuth.\nOWASP Top 10: Open Web Application Security Project's list of critical web application security risks. OrionAuth helps mitigate several of these, including weaknesses in Identification & Authentication and Access Control.\nNIST SP 800-63: Digital Identity Guidelines from the U.S. National Institute of Standards and Technology, offering comprehensive guidance on authentication assurance.\nGDPR (General Data Protection Regulation): If your application processes personal data of EU residents, refer to the GDPR guidelines for data privacy and protection.","category":"page"},{"location":"manual/security/","page":"OrionAuth Security Considerations and Best Practices","title":"OrionAuth Security Considerations and Best Practices","text":"We encourage you to include links to these (and other relevant standards like SOC 2, ISO 27001, PCI DSS, if applicable to your specific domain) in your company's security policy and documentation.","category":"page"},{"location":"manual/security/#2.-Core-Security-Features-of-OrionAuth","page":"OrionAuth Security Considerations and Best Practices","title":"2. Core Security Features of OrionAuth","text":"","category":"section"},{"location":"manual/security/#2.1-JWT-Based-Session-Handling","page":"OrionAuth Security Considerations and Best Practices","title":"2.1 JWT-Based Session Handling","text":"","category":"section"},{"location":"manual/security/","page":"OrionAuth Security Considerations and Best Practices","title":"OrionAuth Security Considerations and Best Practices","text":"OrionAuth uses JSON Web Tokens for managing user sessions in a stateless manner.","category":"page"},{"location":"manual/security/","page":"OrionAuth Security Considerations and Best Practices","title":"OrionAuth Security Considerations and Best Practices","text":"Algorithms: Supports HS256 and HS512 (HMAC with SHA-256/SHA-512) for signing tokens, utilizing Nettle.jl as the cryptographic backend. The algorithm is configurable via ENV[\"OrionAuth_ALGORITHM\"].\nSecret Key: A strong, unique secret key, configured via ENV[\"OrionAuth_SECRET\"], is used for signing and verifying tokens. This key's confidentiality is critical.\nClaims:\nDefault claims automatically included in the JWT payload by OrionAuth.GenerateJWT are:\nsub: Subject (User ID)\nname: User's name\nemail: User's email\nuuid: User's UUID\nroles: List of roles assigned to the user (names or IDs, fetched by GetUserRoles)\npermissions: List of permissions assigned to the user (derived from roles and direct assignments, fetched by GetUserPermissions)\niat: Issued At (timestamp of token generation)\nexp: Expiration Time (timestamp, calculated based on ENV[\"OrionAuth_JWT_EXP\"])\nCustom Claims: Additional standard claims like iss (issuer - ENV[\"OrionAuth_ISSUER\"] is available but must be manually added to the payload), aud (audience), nbf (not before), and jti (JWT ID for revocability) can be incorporated by customizing the payload construction within the GenerateJWT function in src/auth.jl.\nToken Expiration: The JWT expiration time is configurable in minutes via ENV[\"OrionAuth_JWT_EXP\"].\nToken Generation Example (Conceptual):   ```julia\nIn your application, after a user signs in:\nuserobject, tokenresponse_json = OrionAuth.signin(\"user@example.com\", \"password123\")\nThe tokenresponsejson string contains the access_token.\nInternally, OrionAuth.GenerateJWT(user_object) is called.\n```\nRefresh Tokens: Currently, OrionAuth V1 does not have built-in support for refresh tokens or advanced token revocation (e.g., blacklisting jti). These are considered for future enhancements.","category":"page"},{"location":"manual/security/#2.2-Password-Security","page":"OrionAuth Security Considerations and Best Practices","title":"2.2 Password Security","text":"","category":"section"},{"location":"manual/security/","page":"OrionAuth Security Considerations and Best Practices","title":"OrionAuth Security Considerations and Best Practices","text":"OrionAuth prioritizes strong password protection.","category":"page"},{"location":"manual/security/","page":"OrionAuth Security Considerations and Best Practices","title":"OrionAuth Security Considerations and Best Practices","text":"Hashing Algorithm (Default): Uses libsodium's Argon2id implementation via crypto_pwhash_str, leveraging the OPSLIMIT_MODERATE and MEMLIMIT_MODERATE cost parameters by default. The algorithm is self-contained (salt + parameters + hash) and represented in the $argon2id$... format.\nAlgorithm Selection: Choose between the built-in argon2id (default) and legacy sha512 implementations via ENV[\"OrionAuth_PASSWORD_ALGORITHM\"] or by passing the desired algorithm object (e.g., OrionAuth.LegacySHA512Algorithm()) to hash_password.\nLegacy Compatibility: Existing SHA-512 hashes (\"sha512&...\") continue to verify successfully. Applications that still need to generate SHA-512 hashes can opt-in by selecting the :sha512 algorithm and may tune the iteration count with ENV[\"OrionAuth_MIN_PASSWORD_ITTERATIONS\"].\nConstant-Time Verification: Argon2id verification is delegated to libsodium, which performs constant-time checks internally. Legacy SHA-512 verification keeps the original iterative approach; high-security deployments should phase it out or wrap verification with additional mitigations if necessary.","category":"page"},{"location":"manual/security/#2.3-Secrets-Management-(Application/Infrastructure-Responsibility)","page":"OrionAuth Security Considerations and Best Practices","title":"2.3 Secrets Management (Application/Infrastructure Responsibility)","text":"","category":"section"},{"location":"manual/security/","page":"OrionAuth Security Considerations and Best Practices","title":"OrionAuth Security Considerations and Best Practices","text":"The OrionAuth_SECRET (for JWT signing), database credentials, and any other sensitive keys used by your application should be managed પાણી.\nRecommendation: Store these secrets in a dedicated secrets management solution (e.g., HashiCorp Vault, AWS Secrets Manager, Azure Key Vault). Do not hardcode them or commit them to version control.\nRegularly rotate secrets and audit access logs according to your organization's security policy.","category":"page"},{"location":"manual/security/#2.4-Transport-Security-(Application/Infrastructure-Responsibility)","page":"OrionAuth Security Considerations and Best Practices","title":"2.4 Transport Security (Application/Infrastructure Responsibility)","text":"","category":"section"},{"location":"manual/security/","page":"OrionAuth Security Considerations and Best Practices","title":"OrionAuth Security Considerations and Best Practices","text":"Recommendation: Enforce TLS 1.2 or higher (HTTPS) for all endpoints that handle authentication requests or transmit JWTs.\nImplement HTTP Strict Transport Security (HSTS) headers to ensure browsers only connect via HTTPS.\nA reverse proxy (e.g., NGINX, Traefik, Caddy) can be used for TLS termination, certificate management, and potentially as a first line of defense for rate limiting.","category":"page"},{"location":"manual/security/#2.5-Data-Encryption-At-Rest-(Application/Infrastructure-Responsibility-for-general-application-data)","page":"OrionAuth Security Considerations and Best Practices","title":"2.5 Data Encryption At Rest (Application/Infrastructure Responsibility - for general application data)","text":"","category":"section"},{"location":"manual/security/","page":"OrionAuth Security Considerations and Best Practices","title":"OrionAuth Security Considerations and Best Practices","text":"OrionAuth itself does not encrypt general application data stored by your system (e.g., user profile information beyond authentication details, application-specific sensitive data).\nRecommendation:\nField-Level Encryption: For highly sensitive fields in your database, consider encrypting them before insertion (e.g., using AES-GCM via Nettle.jl or another cryptographic library).\nDatabase Encryption: Utilize disk-level encryption provided by your database system or cloud provider (e.g., LUKS, AWS EBS encryption, Azure Disk Encryption).","category":"page"},{"location":"manual/security/#2.6-Audit-Logging-(OrionAuth-Feature)","page":"OrionAuth Security Considerations and Best Practices","title":"2.6 Audit Logging (OrionAuth Feature)","text":"","category":"section"},{"location":"manual/security/","page":"OrionAuth Security Considerations and Best Practices","title":"OrionAuth Security Considerations and Best Practices","text":"OrionAuth includes basic audit logging capabilities.","category":"page"},{"location":"manual/security/","page":"OrionAuth Security Considerations and Best Practices","title":"OrionAuth Security Considerations and Best Practices","text":"Log Table: Actions are logged to the OrionAuth_Log table.\nInformation Logged: Includes userId, action performed (e.g., \"signup\", \"signin\", \"AssignRoleToUser\"), and a timestamp.\nImmutability (Recommendation): While OrionAuth inserts logs, true immutability and integrity depend on database permissions and backup strategies.\nDatabase Role (Recommendation): Create a dedicated database user for your application that has minimal necessary privileges on OrionAuth tables. For the OrionAuth_Log table, this user might primarily need INSERT and SELECT permissions. Example:   sql   GRANT SELECT, INSERT ON OrionAuth_Log TO 'your_app_auth_user';\nLog Retention (Application Policy): Log retention periods and backup strategies should be defined by your organization's policies and compliance requirements.","category":"page"},{"location":"manual/security/#2.7-Access-Controls-(OrionAuth-Feature)","page":"OrionAuth Security Considerations and Best Practices","title":"2.7 Access Controls (OrionAuth Feature)","text":"","category":"section"},{"location":"manual/security/","page":"OrionAuth Security Considerations and Best Practices","title":"OrionAuth Security Considerations and Best Practices","text":"OrionAuth provides a Role-Based Access Control (RBAC) system.","category":"page"},{"location":"manual/security/","page":"OrionAuth Security Considerations and Best Practices","title":"OrionAuth Security Considerations and Best Practices","text":"Models: Defines OrionAuth_Role, OrionAuth_Permission, OrionAuth_UserRole, OrionAuth_RolePermission, and OrionAuth_UserPermission tables to manage fine-grained access.\nFunctionality: Provides functions to assign roles to users (AssignRoleToUser), assign permissions to roles (via SyncRolesAndPermissions or direct table manipulation), assign direct permissions to users (AssignPermissionToUser), and check user permissions (CheckPermission, GetUserPermissions).\nDatabase Hardening (Recommendation): Complement OrionAuth's RBAC by configuring restrictive database grants for your application's database user, minimizing privileges on critical tables (e.g., restricting DROP/DELETE on core auth tables).","category":"page"},{"location":"manual/security/#2.8-Rate-Limiting-and-Brute-Force-Protection-(Planned-/-Application-or-Infrastructure-Responsibility-for-V1)","page":"OrionAuth Security Considerations and Best Practices","title":"2.8 Rate Limiting and Brute-Force Protection (Planned / Application or Infrastructure Responsibility for V1)","text":"","category":"section"},{"location":"manual/security/","page":"OrionAuth Security Considerations and Best Practices","title":"OrionAuth Security Considerations and Best Practices","text":"OrionAuth Package: Rate limiting and advanced brute-force protection (like account lockout after N failed attempts) are listed as \"Upcoming Features\" in the README for direct inclusion in the package.\nFor V1 / Current Implementation: It is highly recommended to implement these protections at the application layer or using infrastructure tools (e.g., a reverse proxy, WAF). This includes limiting login attempts per IP and/or per user account.","category":"page"},{"location":"manual/security/#2.9-Multi-Factor-Authentication-(MFA)-(Planned)","page":"OrionAuth Security Considerations and Best Practices","title":"2.9 Multi-Factor Authentication (MFA) (Planned)","text":"","category":"section"},{"location":"manual/security/","page":"OrionAuth Security Considerations and Best Practices","title":"OrionAuth Security Considerations and Best Practices","text":"OrionAuth Package: MFA (e.g., TOTP via RFC 6238) is listed as an \"Upcoming Feature\" in the README.\nCurrent Implementation: For V1, if MFA is required, it would need to be integrated as a separate layer by the consuming application.","category":"page"},{"location":"manual/security/#3.-Organizational-vs.-Package-Responsibilities","page":"OrionAuth Security Considerations and Best Practices","title":"3. Organizational vs. Package Responsibilities","text":"","category":"section"},{"location":"manual/security/","page":"OrionAuth Security Considerations and Best Practices","title":"OrionAuth Security Considerations and Best Practices","text":"Aspect OrionAuth Package Responsibility Company / Infrastructure Responsibility\nSecurity Policy Documentation Provides this security.md as a guide. Formal policies, regular audits, referencing standards.\nJWT Algorithm & Implementation Provides secure JWT (HS256/HS512) generation & verification. Choosing a strong OrionAuth_SECRET.\nPassword Hashing Default Argon2id via libsodium with optional legacy SHA-512 fallback. Educating users on strong password creation.\nSecret Rotation & Management Uses ENV vars for secrets; facilitates updates by app restart. Implement vault, schedule rotation, manage access.\nPenetration Testing Aims for secure code; testable via its API (when used in an app). Conduct regular penetration tests and remediate findings.\nBackup & Recovery Defines database models. Implement DRP, define RPO/RTO, manage backup scripts.\nEnvironment Isolation Configurable via ENV variables. Implement VPCs, IAM, network policies, secure CI/CD.\nTransport Layer Security (TLS) N/A (operates at a higher layer). Enforce HTTPS, manage certificates.\nRate Limiting / Brute-Force (V1) Planned for future; currently N/A. Implement at application or infrastructure level.\nMulti-Factor Authentication (V1) Planned for future; currently N/A. Implement separately if required for V1.\nAudit Log Storage & Retention Provides OrionAuth_Log table and inserts records. Manage DB storage, backups, retention policies, SIEM anexo.\nRBAC Definition & Enforcement Provides models and functions for RBAC. Define appropriate roles & permissions for the application.","category":"page"},{"location":"manual/security/#4.-Use-Cases-and-Implementation-Levels","page":"OrionAuth Security Considerations and Best Practices","title":"4. Use Cases and Implementation Levels","text":"","category":"section"},{"location":"manual/security/","page":"OrionAuth Security Considerations and Best Practices","title":"OrionAuth Security Considerations and Best Practices","text":"This section provides guidance on which security features to prioritize based on your application's sensitivity and requirements.","category":"page"},{"location":"manual/security/","page":"OrionAuth Security Considerations and Best Practices","title":"OrionAuth Security Considerations and Best Practices","text":"Use Case Core OrionAuth Features Utilized Key Additional Concerns / Responsibilities (Company/Infra)\nMVP / Prototyping JWT (HS512) + Argon2id password hashing, Basic Audit Logging (OrionAuth_Log). TLS/HTTPS, strong OrionAuth_SECRET, basic ENV var management.\nNon-Sensitive Web App All MVP features + robust RBAC (GetUserPermissions, etc.). Vault for secrets, basic rate limiting (app/proxy), regular dependency updates.\nMedium-Sensitivity App All above + enforce Argon2id parameters review, begin MFA rollout. Stricter RBAC policies, SIEM integration for logs, defined log retention, field-level encryption for sensitive app data.\nFintech / Regulated App All above + mandatory MFA, centralized secrets, Argon2id monitoring. Formal SOC 2/ISO 27001 controls, regular pentests, robust DRP, immutable audit pipeline, compliance reporting (PCI/GDPR as applicable), dedicated security team.","category":"page"},{"location":"manual/security/","page":"OrionAuth Security Considerations and Best Practices","title":"OrionAuth Security Considerations and Best Practices","text":"Note: Always adjust configurations (e.g., JWT expiration, password hashing iterations) based on your specific threat model, performance considerations, and organizational security requirements. Regularly review and update your security practices as both your application and the threat landscape evolve.","category":"page"},{"location":"security/references/#Security-References","page":"Security References","title":"Security References","text":"","category":"section"},{"location":"security/references/","page":"Security References","title":"Security References","text":"This document consolidates all official standards, guidelines, and references used to design and enforce the OrionAuth.jl security model.","category":"page"},{"location":"security/references/","page":"Security References","title":"Security References","text":"","category":"page"},{"location":"security/references/#General-Security-Guidelines","page":"Security References","title":"General Security Guidelines","text":"","category":"section"},{"location":"security/references/","page":"Security References","title":"Security References","text":"OWASP Cheat Sheet Series\nAuthorization Cheat Sheet\nLogging Cheat Sheet\nInsecure Direct Object Reference Prevention Cheat Sheet\nOWASP ASVS v4.0\nAccess Control requirements and verification levels\nOWASP Testing Guide\nAuthorization Testing\nOWASP Top 10 - 2021\nA01:2021 - Broken Access Control\nCWE Top 25 Most Dangerous Software Weaknesses\nCWE-862: Missing Authorization\nCWE-863: Incorrect Authorization","category":"page"},{"location":"security/references/","page":"Security References","title":"Security References","text":"","category":"page"},{"location":"security/references/#Authentication-and-Identity","page":"Security References","title":"Authentication and Identity","text":"","category":"section"},{"location":"security/references/","page":"Security References","title":"Security References","text":"NIST Special Publication 800-63B\nDigital Identity Guidelines\nAuthentication Assurance Levels (AAL), Level 1 as baseline\nOAuth 2.0 Authorization Framework (RFC 6749)\nOAuth 2.1 (Draft)","category":"page"},{"location":"security/references/","page":"Security References","title":"Security References","text":"","category":"page"},{"location":"security/references/#Access-Control-Models-and-Enforcement","page":"Security References","title":"Access Control Models and Enforcement","text":"","category":"section"},{"location":"security/references/","page":"Security References","title":"Security References","text":"Policy Enforcement in RFC 2904 (Policy Core Information Model - PCIM)\nReferenced only, not enforced. Used for access control consolidation principles.","category":"page"},{"location":"security/references/","page":"Security References","title":"Security References","text":"","category":"page"},{"location":"security/references/#Password-Security-and-Threat-Intelligence","page":"Security References","title":"Password Security and Threat Intelligence","text":"","category":"section"},{"location":"security/references/","page":"Security References","title":"Security References","text":"SecLists - Passwords\nTop common and compromised passwords reference for future password strength validation.","category":"page"},{"location":"security/references/","page":"Security References","title":"Security References","text":"","category":"page"},{"location":"security/references/#Secrets-and-Configuration-Management","page":"Security References","title":"Secrets and Configuration Management","text":"","category":"section"},{"location":"security/references/","page":"Security References","title":"Security References","text":"Environment Variables (ENV)\nUsed for application secrets injection and management.\nShould be handled securely in CI/CD and production environments.","category":"page"},{"location":"security/references/","page":"Security References","title":"Security References","text":"","category":"page"},{"location":"security/references/#Logging-and-Audit-Trail","page":"Security References","title":"Logging and Audit Trail","text":"","category":"section"},{"location":"security/references/","page":"Security References","title":"Security References","text":"OWASP Cheat Sheet: Logging","category":"page"},{"location":"security/references/","page":"Security References","title":"Security References","text":"","category":"page"},{"location":"security/references/#Special-Considerations","page":"Security References","title":"Special Considerations","text":"","category":"section"},{"location":"security/references/","page":"Security References","title":"Security References","text":"Future MFA implementation aligned with NIST 800-63B AAL2/AAL3 when applicable.","category":"page"},{"location":"security/references/","page":"Security References","title":"Security References","text":"","category":"page"},{"location":"security/threat_model/#Threat-Model","page":"Threat Model","title":"Threat Model","text":"","category":"section"},{"location":"security/threat_model/","page":"Threat Model","title":"Threat Model","text":"This document outlines the primary threat scenarios considered during the design of OrionAuth.jl. It explicitly defines attack vectors covered and those delegated to integrators.","category":"page"},{"location":"security/threat_model/","page":"Threat Model","title":"Threat Model","text":"","category":"page"},{"location":"security/threat_model/#Threat-Actors","page":"Threat Model","title":"Threat Actors","text":"","category":"section"},{"location":"security/threat_model/","page":"Threat Model","title":"Threat Model","text":"External attackers (unauthenticated)\nInternal attackers (authenticated users attempting privilege escalation)\nCompromised user credentials\nMalicious integrator or misconfigured integration","category":"page"},{"location":"security/threat_model/","page":"Threat Model","title":"Threat Model","text":"","category":"page"},{"location":"security/threat_model/#Threat-Scenarios-and-Mitigations","page":"Threat Model","title":"Threat Scenarios and Mitigations","text":"","category":"section"},{"location":"security/threat_model/#Unauthorized-Access-(Broken-Access-Control)","page":"Threat Model","title":"Unauthorized Access (Broken Access Control)","text":"","category":"section"},{"location":"security/threat_model/","page":"Threat Model","title":"Threat Model","text":"Scenario: Bypass of access control via missing or incorrect authorization checks.","category":"page"},{"location":"security/threat_model/","page":"Threat Model","title":"Threat Model","text":"Mitigation:","category":"page"},{"location":"security/threat_model/","page":"Threat Model","title":"Threat Model","text":"Deny by default on roles and permissions.\nManual integration of access control required.\nJWT unsigned tokens are rejected by default.","category":"page"},{"location":"security/threat_model/","page":"Threat Model","title":"Threat Model","text":"Integrator Responsibility:","category":"page"},{"location":"security/threat_model/","page":"Threat Model","title":"Threat Model","text":"Explicitly protect all routes requiring authorization.\nImplement logic to validate user permissions where needed.","category":"page"},{"location":"security/threat_model/","page":"Threat Model","title":"Threat Model","text":"","category":"page"},{"location":"security/threat_model/#Token-Forgery-and-Session-Hijacking","page":"Threat Model","title":"Token Forgery and Session Hijacking","text":"","category":"section"},{"location":"security/threat_model/","page":"Threat Model","title":"Threat Model","text":"Scenario: Forged JWTs or replayed tokens.","category":"page"},{"location":"security/threat_model/","page":"Threat Model","title":"Threat Model","text":"Mitigation:","category":"page"},{"location":"security/threat_model/","page":"Threat Model","title":"Threat Model","text":"JWTs must be signed and verified.\nUnsigned JWTs are automatically rejected.","category":"page"},{"location":"security/threat_model/","page":"Threat Model","title":"Threat Model","text":"Integrator Responsibility:","category":"page"},{"location":"security/threat_model/","page":"Threat Model","title":"Threat Model","text":"Implement appropriate token expiration and refresh logic.","category":"page"},{"location":"security/threat_model/","page":"Threat Model","title":"Threat Model","text":"","category":"page"},{"location":"security/threat_model/#Brute-Force-and-Credential-Stuffing","page":"Threat Model","title":"Brute Force and Credential Stuffing","text":"","category":"section"},{"location":"security/threat_model/","page":"Threat Model","title":"Threat Model","text":"Scenario: Attacker attempts multiple passwords or reused passwords from breaches.","category":"page"},{"location":"security/threat_model/","page":"Threat Model","title":"Threat Model","text":"Mitigation:","category":"page"},{"location":"security/threat_model/","page":"Threat Model","title":"Threat Model","text":"Not currently implemented.\nFuture roadmap: rate limiting, password leak detection.","category":"page"},{"location":"security/threat_model/","page":"Threat Model","title":"Threat Model","text":"Integrator Responsibility:","category":"page"},{"location":"security/threat_model/","page":"Threat Model","title":"Threat Model","text":"Until implemented, integrators should deploy external protections (e.g. WAF, reverse proxies with rate limiting).","category":"page"},{"location":"security/threat_model/","page":"Threat Model","title":"Threat Model","text":"","category":"page"},{"location":"security/threat_model/#Abuse-of-Application-Secrets","page":"Threat Model","title":"Abuse of Application Secrets","text":"","category":"section"},{"location":"security/threat_model/","page":"Threat Model","title":"Threat Model","text":"Scenario: Compromise of ENV variables exposing secrets.","category":"page"},{"location":"security/threat_model/","page":"Threat Model","title":"Threat Model","text":"Mitigation:","category":"page"},{"location":"security/threat_model/","page":"Threat Model","title":"Threat Model","text":"Secrets are injected via ENV.\nSecure deployment and CI/CD practices required.","category":"page"},{"location":"security/threat_model/","page":"Threat Model","title":"Threat Model","text":"Integrator Responsibility:","category":"page"},{"location":"security/threat_model/","page":"Threat Model","title":"Threat Model","text":"Protect ENV and infrastructure secrets using best practices.","category":"page"},{"location":"security/threat_model/","page":"Threat Model","title":"Threat Model","text":"","category":"page"},{"location":"security/threat_model/#Insider-Threat-and-Excessive-Privileges","page":"Threat Model","title":"Insider Threat and Excessive Privileges","text":"","category":"section"},{"location":"security/threat_model/","page":"Threat Model","title":"Threat Model","text":"Scenario: Authenticated user escalates privileges or abuses assigned roles.","category":"page"},{"location":"security/threat_model/","page":"Threat Model","title":"Threat Model","text":"Mitigation:","category":"page"},{"location":"security/threat_model/","page":"Threat Model","title":"Threat Model","text":"Least privilege enforced via RBAC.\nDeny by default on permissions.\nLogging of role changes and access usage.","category":"page"},{"location":"security/threat_model/","page":"Threat Model","title":"Threat Model","text":"Integrator Responsibility:","category":"page"},{"location":"security/threat_model/","page":"Threat Model","title":"Threat Model","text":"Monitor logs and audit sensitive actions.","category":"page"},{"location":"security/threat_model/","page":"Threat Model","title":"Threat Model","text":"","category":"page"},{"location":"security/threat_model/#Out-of-Scope","page":"Threat Model","title":"Out of Scope","text":"","category":"section"},{"location":"security/threat_model/","page":"Threat Model","title":"Threat Model","text":"Automatic route protection.\nDistributed denial-of-service (DDoS) attacks.\nSide-channel attacks.\nMFA and password leak verification (planned).","category":"page"},{"location":"security/threat_model/","page":"Threat Model","title":"Threat Model","text":"","category":"page"},{"location":"#OrionAuth.jl","page":"Home","title":"OrionAuth.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Easy Authentication for Genie APIs.","category":"page"},{"location":"#Package-Features","page":"Home","title":"Package Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Authentication using stateless token;\nAuthorization with RBAC;\nIntegration with OrionORM.jl;","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"security/vulnerability_report/#Vulnerability-Reporting-and-Handling-Process","page":"Vulnerability Reporting and Handling Process","title":"Vulnerability Reporting and Handling Process","text":"","category":"section"},{"location":"security/vulnerability_report/","page":"Vulnerability Reporting and Handling Process","title":"Vulnerability Reporting and Handling Process","text":"OrionAuth.jl is committed to maintaining a secure and reliable authentication system. This document describes the process for reporting, handling, and disclosing security vulnerabilities. The process does not involve CVE assignment and is designed for simple and efficient handling via GitHub.","category":"page"},{"location":"security/vulnerability_report/","page":"Vulnerability Reporting and Handling Process","title":"Vulnerability Reporting and Handling Process","text":"","category":"page"},{"location":"security/vulnerability_report/#Reporting-Vulnerabilities","page":"Vulnerability Reporting and Handling Process","title":"Reporting Vulnerabilities","text":"","category":"section"},{"location":"security/vulnerability_report/","page":"Vulnerability Reporting and Handling Process","title":"Vulnerability Reporting and Handling Process","text":"Security issues should be reported privately and responsibly through the GitHub Security Advisories feature. To report a vulnerability:","category":"page"},{"location":"security/vulnerability_report/","page":"Vulnerability Reporting and Handling Process","title":"Vulnerability Reporting and Handling Process","text":"Go to the OrionAuth.jl GitHub repository.\nOpen a new Security Advisory (under the \"Security\" tab → \"Advisories\" → \"New draft security advisory\").\nProvide detailed information:\nDescription of the issue.\nSteps to reproduce (if applicable).\nPotential impact.\nAny relevant logs or PoCs (proof of concept).","category":"page"},{"location":"security/vulnerability_report/","page":"Vulnerability Reporting and Handling Process","title":"Vulnerability Reporting and Handling Process","text":"Reports should not be submitted via issues or pull requests to avoid public disclosure.","category":"page"},{"location":"security/vulnerability_report/","page":"Vulnerability Reporting and Handling Process","title":"Vulnerability Reporting and Handling Process","text":"","category":"page"},{"location":"security/vulnerability_report/#Handling-and-Response-Timeline","page":"Vulnerability Reporting and Handling Process","title":"Handling and Response Timeline","text":"","category":"section"},{"location":"security/vulnerability_report/","page":"Vulnerability Reporting and Handling Process","title":"Vulnerability Reporting and Handling Process","text":"After receiving a vulnerability report, the maintainers will make best efforts to:","category":"page"},{"location":"security/vulnerability_report/","page":"Vulnerability Reporting and Handling Process","title":"Vulnerability Reporting and Handling Process","text":"Acknowledge receipt within 5 days.\nAnalyze the issue and validate within a reasonable timeframe (usually within 15 days depending on complexity).\nDevelop and test a fix as soon as practical. No guaranteed timeline.\nPublish a patched release and security advisory once resolved.","category":"page"},{"location":"security/vulnerability_report/","page":"Vulnerability Reporting and Handling Process","title":"Vulnerability Reporting and Handling Process","text":"","category":"page"},{"location":"security/vulnerability_report/#Disclosure","page":"Vulnerability Reporting and Handling Process","title":"Disclosure","text":"","category":"section"},{"location":"security/vulnerability_report/","page":"Vulnerability Reporting and Handling Process","title":"Vulnerability Reporting and Handling Process","text":"Once a fix is available:","category":"page"},{"location":"security/vulnerability_report/","page":"Vulnerability Reporting and Handling Process","title":"Vulnerability Reporting and Handling Process","text":"The security advisory will be updated and made public.\nA patched release will be published.\nClear upgrade instructions and mitigation recommendations (if necessary) will be included.","category":"page"},{"location":"security/vulnerability_report/","page":"Vulnerability Reporting and Handling Process","title":"Vulnerability Reporting and Handling Process","text":"","category":"page"},{"location":"security/vulnerability_report/#Limitations","page":"Vulnerability Reporting and Handling Process","title":"Limitations","text":"","category":"section"},{"location":"security/vulnerability_report/","page":"Vulnerability Reporting and Handling Process","title":"Vulnerability Reporting and Handling Process","text":"No guaranteed response or resolution timelines, but best efforts will always be made.\nNo CVE assignment or external vulnerability database publication.\nPriority is given to critical and high-impact issues.","category":"page"},{"location":"security/vulnerability_report/","page":"Vulnerability Reporting and Handling Process","title":"Vulnerability Reporting and Handling Process","text":"","category":"page"}]
}
